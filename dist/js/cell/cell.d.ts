import { RoundedVector3D } from "@mat3ra/code";
import { Coordinate3DSchema, LatticeVectorsSchema as CellSchema, Matrix3X3Schema, Vector3DSchema } from "@mat3ra/esse/dist/js/types";
export declare class Cell implements CellSchema {
    static RoundedVector3DClassReference: typeof RoundedVector3D;
    static roundPrecision: number;
    static tolerance: number;
    static defaultConfig: CellSchema;
    a: CellSchema["a"];
    b: CellSchema["b"];
    c: CellSchema["c"];
    alat: number;
    units: CellSchema["units"];
    constructor(config?: CellSchema);
    static fromVectorsArray(vectors: Matrix3X3Schema): Cell;
    get _a(): RoundedVector3D;
    get _b(): RoundedVector3D;
    get _c(): RoundedVector3D;
    get vectorArrays(): Matrix3X3Schema;
    get vectorArraysRounded(): Matrix3X3Schema;
    get volume(): number;
    get volumeRounded(): number;
    clone(): Cell;
    cloneAndScaleByMatrix(matrix: Matrix3X3Schema): Cell;
    convertPointToCartesian(point: Coordinate3DSchema): Coordinate3DSchema;
    convertPointToCrystal(point: Coordinate3DSchema): Coordinate3DSchema;
    isPointInsideCellCartesian(point: Coordinate3DSchema): boolean;
    isPointInsideCellCrystal(point: Coordinate3DSchema): boolean;
    isPointInsideCell(point: Coordinate3DSchema, useCrystal?: boolean): boolean;
    getMostCollinearVectorIndex(testVector: Vector3DSchema): number;
    scaleByMatrix(matrix: number[][]): void;
    toJSON(): CellSchema;
}
