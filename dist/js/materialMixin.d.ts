import type { InMemoryEntity } from "@mat3ra/code/dist/js/entity";
import type { NamedEntity } from "@mat3ra/code/dist/js/entity/mixins/NamedEntityMixin";
import type { Constructor } from "@mat3ra/code/dist/js/utils/types";
import type { AnyObject } from "@mat3ra/esse/dist/js/esse/types";
import type { AtomicConstraintsSchema, ConsistencyCheck, DerivedPropertiesSchema, FileSourceSchema, LatticeSchema, MaterialSchema } from "@mat3ra/esse/dist/js/types";
import type { BasisConfig } from "./basis/basis";
import { type ConstrainedBasisConfig, ConstrainedBasis } from "./basis/constrained_basis";
import type { AtomicElementValue } from "./basis/elements";
import { Constraint } from "./constraints/constraints";
import { Lattice } from "./lattice/lattice";
export declare const defaultMaterialConfig: MaterialSchema;
export interface MaterialSchemaJSON extends MaterialSchema, AnyObject {
}
export type MaterialMixinProps<T extends Base = Base> = {
    toJSON(): MaterialSchema & AnyObject;
    name: string;
    src: FileSourceSchema | undefined;
    updateFormula(): void;
    isNonPeriodic: boolean;
    getDerivedPropertyByName(name: string): DerivedPropertiesSchema[0] | undefined;
    getDerivedProperties(): DerivedPropertiesSchema;
    formula: string;
    unitCellFormula: string;
    unsetFileProps(): void;
    setBasis(textOrObject: string | BasisConfig, format?: string, unitz?: string): void;
    setBasisConstraints(constraints: Constraint[]): void;
    setBasisConstraintsFromArrayOfObjects(constraints: AtomicConstraintsSchema): void;
    basis: OptionallyConstrainedBasisConfig;
    Basis: ConstrainedBasis;
    uniqueElements: AtomicElementValue[];
    lattice: LatticeSchema;
    Lattice: Lattice;
    getInchiStringForHash(): string;
    calculateHash(salt?: string, isScaled?: boolean, bypassNonPeriodicCheck?: boolean): string;
    hash: string;
    get scaledHash(): string;
    external: MaterialSchema["external"];
    toCrystal(): void;
    toCartesian(): void;
    getBasisAsXyz(fractional?: boolean): string;
    getAsQEFormat(): string;
    getAsPOSCAR(ignoreOriginal?: boolean, omitConstraints?: boolean): string;
    getACopyWithConventionalCell(): T;
    getConsistencyChecks(): ConsistencyCheck[];
    getBasisConsistencyChecks(): ConsistencyCheck[];
};
type MaterialMixinStaticProps = {
    defaultConfig: MaterialSchema;
    constructMaterialFileSource(fileName: string, fileContent: string, fileExtension: string): FileSourceSchema;
};
export type MaterialInMemoryEntity = InMemoryEntity & MaterialMixinProps;
export type MaterialMixinConstructor = Constructor<MaterialMixinProps> & MaterialMixinStaticProps;
type OptionallyConstrainedBasisConfig = BasisConfig & Partial<Pick<ConstrainedBasisConfig, "constraints">>;
type Base = InMemoryEntity & NamedEntity;
export declare function materialMixin<T extends Constructor<Base>>(item: T): void;
export {};
